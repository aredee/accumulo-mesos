package aredee.mesos.frameworks.accumulo.scheduler;

import org.apache.mesos.Protos;
import org.apache.mesos.SchedulerDriver;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Scheduler implements org.apache.mesos.Scheduler {
    private static final Logger LOGGER = LoggerFactory.getLogger(Scheduler.class);

    private final Cluster cluster;

    public Scheduler(final Cluster cluster){
        this.cluster = cluster;
    }

    /**
     * Invoked when the scheduler successfully registers with a Mesos
     * master. A unique ID (generated by the master) used for
     * distinguishing this framework from others and MasterInfo
     * with the IP and port of the current master are provided as arguments.
     *
     * @param schedulerDriver
     * @param frameworkID
     * @param masterInfo      Info about the current master, including IP and port.
     * @see org.apache.mesos.SchedulerDriver
     * @see Protos.FrameworkID
     * @see Protos.MasterInfo
     */
    @Override
    public void registered(SchedulerDriver schedulerDriver, Protos.FrameworkID frameworkID, Protos.MasterInfo masterInfo) {
        LOGGER.info("Framework Registered: {}", frameworkID.getValue());
        cluster.setFrameworkId(frameworkID.getValue()); // ID is only available after registration.
        cluster.restore(schedulerDriver);
    }

    /**
     * Invoked when the scheduler re-registers with a newly elected Mesos master.
     * This is only called when the scheduler has previously been registered.
     * MasterInfo containing the updated information about the elected master
     * is provided as an argument.
     *
     * @param schedulerDriver
     * @param masterInfo      The updated information about the elected master.
     * @see org.apache.mesos.SchedulerDriver
     * @see Protos.MasterInfo
     */
    @Override
    public void reregistered(SchedulerDriver schedulerDriver, Protos.MasterInfo masterInfo) {
        LOGGER.info("Framework Re-Registered");
        cluster.restore(schedulerDriver);
    }

    /**
     * Invoked when resources have been offered to this framework. A
     * single offer will only contain resources from a single slave.
     * Resources associated with an offer will not be re-offered to
     * _this_ framework until either (a) this framework has rejected
     * those resources (see {@link org.apache.mesos.SchedulerDriver#launchTasks}) or (b)
     * those resources have been rescinded (see {@link org.apache.mesos.Scheduler#offerRescinded}).
     * Note that resources may be concurrently offered to more than one
     * framework at a time (depending on the allocator being used). In
     * that case, the first framework to launch tasks using those
     * resources will be able to use them while the other frameworks
     * will have those resources rescinded (or if a framework has
     * already launched tasks with those resources then those tasks will
     * fail with a TASK_LOST status and a message saying as much).
     *
     * @param schedulerDriver
     * @param list
     * @see org.apache.mesos.SchedulerDriver
     * @see Protos.Offer
     */
    @Override
    public void resourceOffers(SchedulerDriver schedulerDriver, List<Protos.Offer> offers) {
        LOGGER.info("{} Resource Offers Recieved", offers.size());
        cluster.handleOffers(schedulerDriver, offers);
    }

    /**
     * Invoked when an offer is no longer valid (e.g., the slave was
     * lost or another framework used resources in the offer). If for
     * whatever reason an offer is never rescinded (e.g., dropped
     * message, failing over framework, etc.), a framwork that attempts
     * to launch tasks using an invalid offer will receive TASK_LOST
     * status updats for those tasks (see {@link #resourceOffers}).
     *
     * @param schedulerDriver
     * @param offerID
     * @see org.apache.mesos.SchedulerDriver
     * @see Protos.OfferID
     */
    @Override
    public void offerRescinded(SchedulerDriver schedulerDriver, Protos.OfferID offerID) {
        LOGGER.info("Offer Rescinded");
    }

    /**
     * Invoked when the status of a task has changed (e.g., a slave is
     * lost and so the task is lost, a task finishes and an executor
     * sends a status update saying so, etc). If implicit
     * acknowledgements are being used, then returning from this
     * callback _acknowledges_ receipt of this status update! If for
     * whatever reason the scheduler aborts during this callback (or
     * the process exits) another status update will be delivered (note,
     * however, that this is currently not true if the slave sending the
     * status update is lost/fails during that time). If explicit
     * acknowledgements are in use, the scheduler must acknowledge this
     * status on the driver.
     *
     * @param schedulerDriver
     * @param taskStatus
     * @see org.apache.mesos.SchedulerDriver
     * @see Protos.TaskStatus
     */
    @Override
    public void statusUpdate(SchedulerDriver schedulerDriver, Protos.TaskStatus taskStatus) {
        LOGGER.info("Status Update Received");
        cluster.updateTaskStatus(taskStatus);
    }

    /**
     * Invoked when an executor sends a message. These messages are best
     * effort; do not expect a framework message to be retransmitted in
     * any reliable fashion.
     *
     * @param schedulerDriver
     * @param executorID
     * @param slaveID
     * @param bytes           @see org.apache.mesos.SchedulerDriver
     * @see Protos.ExecutorID
     * @see Protos.SlaveID
     */
    @Override
    public void frameworkMessage(SchedulerDriver schedulerDriver, Protos.ExecutorID executorID, Protos.SlaveID slaveID, byte[] bytes) {
        LOGGER.info("Framework Message received.");
    }

    /**
     * Invoked when the scheduler becomes "disconnected" from the master
     * (e.g., the master fails and another is taking over).
     *
     * @param schedulerDriver@see org.apache.mesos.SchedulerDriver
     */
    @Override
    public void disconnected(SchedulerDriver schedulerDriver) {
        LOGGER.info("Disconnected from Mesos master");
        // new scheduler should reconnect us, but perhaps set something to do after a timeout here.
    }

    /**
     * Invoked when a slave has been determined unreachable (e.g.,
     * machine failure, network partition). Most frameworks will need to
     * reschedule any tasks launched on this slave on a new slave.
     *
     * @param schedulerDriver
     * @param slaveID
     * @see org.apache.mesos.SchedulerDriver
     * @see Protos.SlaveID
     */
    @Override
    public void slaveLost(SchedulerDriver schedulerDriver, Protos.SlaveID slaveID) {
        LOGGER.info("Slave Lost: " + slaveID);
        // TODO notify cluster that a slave was lost. Have executor kill if still running
    }

    /**
     * Invoked when an executor has exited/terminated. Note that any
     * tasks running will have TASK_LOST status updates automagically
     * generated.
     *
     * @param schedulerDriver
     * @param executorID
     * @param slaveID
     * @param i               @see org.apache.mesos.SchedulerDriver
     * @see Protos.ExecutorID
     * @see Protos.SlaveID
     * @see Protos.Status
     */
    @Override
    public void executorLost(SchedulerDriver schedulerDriver, Protos.ExecutorID executorID, Protos.SlaveID slaveID, int i) {
        LOGGER.info("Executor lost: " + executorID + "on slave: " + slaveID + " number " + i);
        // Will update state when TASK_LOST received
    }

    /**
     * Invoked when there is an unrecoverable error in the scheduler or
     * driver. The driver will be aborted BEFORE invoking this callback.
     *
     * @param schedulerDriver
     * @param s
     * @see org.apache.mesos.SchedulerDriver
     */
    @Override
    public void error(SchedulerDriver schedulerDriver, String s) {
        LOGGER.info("Unrecoverable Error in Scheduler or SchedulerDriver: " + s);
    }
}